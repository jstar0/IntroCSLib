# 排序算法编程实践
23090032047 计算机类1班 于景一

---

**写在前面：**

本文所有插图通过*jsDelivr*分发的*GitHub Repo*存储，未免遇到可用性问题。如无法正确显示，请临时查看我的 *“备用_Test6_23090032047_于景一.md”* 文件，该文件的图片使用 *base64* 存储。谢谢老师！

## 1. 实践思路

本次课程总体来说有两个要点，一是“**使用Markdown**”编写实验报告，二是“**冒泡排序和快速排序的算法实现**”。由于在[*第四课*][1]中我们已经研究了“*如何配置Python环境*”，故在本次实验中不加赘述。

### 1.1. Markdown 应用

#### 1.1.1. 基本语法

介绍Markdown中几个基础的语法：

    标题：
    # Heading 1
    ## Heading 2
    ### Heading 3
    #### Heading 4 （以此类推）

    > Quote
    - List
    
    文本类型
    `Code` *Italic* **Bold** ***Italic & Bold***
    [Text](https://www.example.com)
    [Text][1]
    ![Pic](link)

    表格：
    |  表头   | 表头  |
    |  ----  | ----  |
    | 单元格  | 单元格 |
    | 单元格  | 单元格 |

    特别的，在分割符之间通过添加“:”来设置内容和标题栏的对齐方式。
        -: 居右对齐     :- 居左对齐     :-: 居中对齐

    转义：
    \*  \[  \#

    HTML标签：
    <kbd> <b> <i> <em> <sup> <sub> <br>

    [1]: https://www.example.com


#### 1.1.2. 版本控制

1. **在GitHub上新建一个Repo**

    没有可以过多描述的，我新建的是面向Public的私人Repo，命名为`IntroCSLib`，
    您可以[从这里][2]查看。

    ![GitHub Repo][1.1.2.1]

2. **通过Git管理**

    Windows环境下我们通过[Git for Windows][3]进行配置，在此不加赘述。

    Git有许多基础指令。通过在本地初始化一个Repo并提交First Commit来熟悉基本指令。
    
    首先我们设置好面向commit的信息。

        git config --global user.name "King Star"
        git config --global user.email mcxin.y@gmail.com

    注意：`--global`意味着在git全局配置此账号。如需对本项目单独配置，应将其移除。

    接着，我们克隆远程仓库，使用

        git clone https://github.com/USER_NAME/REPO_NAME.git

    此后，在本地目录即可进行项目迭代。对每一次需要提交上传代码的情况，都可以使用

        git add FILE_NAME //上传指定更改的文件，或使用*通配符以上传所有更改
        git commit -m "PUT COMMIT MESSAGE HERE" //标记commit
        git push //提交更改

    对于已更改的Repo，如果要与远端同步，拉取命令为
        
        git pull
    
    以上是基础的利用Git对远程Repo的管理命令。

    ![]()

    图为已配置好的本地GitHub库

3. **通过VS Code内置的Source Control管理**

    通过VS Code打开项目文件，即可实现Source Control，如下图。

    ![]()


4. **其他实现思路**

    在PaaS流行的时代，有更多途径实现版本控制，形成完整的`DevOps`，提高生产力。譬如：
    
    - **GitHub 推出的 Codespaces**: 允许创建在云端运行的VS Code环境，解除本地环境的限制。
    - **GitHub Desktop**: 提供带GUI的版本控制面板。
    
    也有类似Git的版本控制程序：
    - **BitKeeper**: 早期Linux团队管理Linux内核程序码的软件，它的授权制度导致了Git的出现。不过，在Git发行后，它也成为开源软件。
    - **SVN, CVS, RCS...** 在此不做深究。
    - 类似的，其实**OneDrive**也自带版本管理功能，不过并不适用于项目迭代。

    总体来说Git仍是当下情况的不二选择。

    ![]()
    图为 Codespaces 实际运用展示

#### 1.1.3. 档案存取

1. **使用GitHub托管的Repo作为图床**

    1.1. **创建一个新的branch**

    我们需要创建一个新的分支，从而实现轻量部署，支持CDN的分发和展现。

    通过

        git branch NEW_BRANCH_NAME
        git checkout NEW_BRANCH_NAME
        
    或使用

        git checkout -b NEW_BRANCH_NAME
        
    这些指令用来创建并切换分支。欲列出已有分支和目前所在分支，使用

        git branch
    
    值得注意的是，若从本地新建一个分支，需要正确对接到GitHub上的远程仓库。完整的命令应该是
        
        git push --set-upstream origin pub

    如此可以正确地关联并推送。

    1.2. **使用开源管理工具**
    
    如 [PicGo][4]

    ![]()
    图为正确使用PicGo的截图

   
2. **通过jsDelivr等实现CDN加速**

    一个事实是，jsDelivr默认镜像并不能在中国很好地工作，有很多区域是无法访问成功的，如下图。
   
    由于jsDelivr有很多子节点，在此选用基于*Gcore*的以提高可用性，其可用性见下图。

    ![]()

    下图是正确连接到GitHub库并通过HTTP GET到图片的方法

    ![]()

3. **其他思路**
   
    - 使用base64存储图片信息 **(较常用)**
    - 使用相对路径展示
    - 使用PaaS应用实现持续部署，典型如 [Netlify][5] [Railway][6] [Vercel][7]
    - 使用 [Aliyun OSS][8]、[Tencent Cloud COS][9] 等服务商的对象存储管理
    - 使用可信的图床

    ![]()
    该图展示了如何用*base64*在Markdown中显示图片。本图即由base64存取。

    ![]()
    图为Vercel持续部署展示

    ![]()
    图为Aliyun OSS实战展示

### 1.2. 冒泡排序的核心算法

#### 1.2.1. 算法实现



#### 1.2.2 时间复杂度



### 1.3. 快速排序的核心算法

#### 1.3.1. 算法组成

1. **算法实现**

    由于快速排序算法具有多种实现方式，为便于研究，我们将算法分为*分区方案 (Partition Scheme)* 和*实现方式 (Implementation Issues)*，对于后者我们仅讨论其中相当重要的部分：*基准的选择 (Choice of pivot)* 、*重复元素情况 (Repeated elements)* 及 *序列较短则用插入排序*。
    
    ([*See Also*][10])

    快速排序的基本思路是分治。不管是何种具体方法，其基本思路是一致的，即：
    
    1. 判断：如果目标数组元素少于两个，则立即返回，无事可做。
    
         注：对于其他较短的情况，或许可以使用到其他排序方法，因为快速排序的优势主要体现在*较大*的范围中。

    2. 选取基准 (pivot)：取决于具体的*分区方案*和*实现方式*。
    3. 重新排序：大于基准的在其右，小于在其左，等于者可移入左右任一位置。
    4. 递归处理：递归地 (recursively) 处理子数组。

2. **时间复杂度**
   
    快速排序是一种不稳定的排序算法。一般的，它的平均时间复杂度是$O(n·logn)$，最坏时间复杂度是$O(n^2)$。通过优化，我们可以适当的使它得到改进。具体的数学证明略。（其中一种证明见 [*OI-Wiki*][11]）

#### 1.3.2. 分区方案 (Partition Scheme)

1. **Nico Lomuto 的方案**

    通过*sorting*, *deviding*, *recursing*三个过程，实现这个算法。该方案通常选择数组中的最后一个元素作为基准(pivot)。
    
    排序一个从 `lo` 到 `hi` 的数组 `A` 的伪代码如下：

        // 给一个（或其中一部分）数组排序，分区，再排序。
        func quicksort(A, lo, hi)
            // 确定下标指向正确的位置
            if lo >= hi || lo < 0 then 
                return
            
            // 给数组分区，得到p作为pivot的项的下标
            p := partition(A, lo, hi) 
                
            // 给得到的两个分区排序
            quicksort(A, lo, p - 1) // Left side of pivot
            quicksort(A, p + 1, hi) // Right side of pivot

        // 给数组分区
        func partition(A, lo, hi)
            pivot := A[hi] // 选择数组中的最后一个元素作为基准(pivot)

            // 定义 Temporary pivot index
            i := lo - 1 // 一般的，如果lo是0，则i的初始值是-1

            for j := lo to hi - 1 do // hi-1是避开最后一项即pivot
                // 如果元素小于等于pivot
                if A[j] <= pivot then 
                    // 移动 Temporary pivot index 向后一位
                    i := i + 1
                    // 将j所在的项与 Temporary pivot index 所在的项交换
                    swap A[i] with A[j]

            // 最后将pivot项放在正确的位置（大子列和小子列之间）
            i := i + 1 // 指向该位置
            swap A[i] with A[hi] // 并不会破坏大小子列的相对有序性
            return i // 返回pivot所在项的下标

    注意：这种方法效率通常低于 Hoare 的原始方案。

2. **Tony Hoare 的方案**

    Hoare 是快速排序算法的原发表者。由于其排序方式并不如 Lomuto 一般显然，其排序示意图见下：

    ![]()


    依然通过*sorting*, *deviding*, *recursing*三个过程，实现这个算法。不过，在这里基准(pivot)通常选数组最中间的那一项。

        // 给一个（或其中一部分）数组排序，分区，再排序。
        func quicksort(A, lo, hi)
        if lo >= 0 && hi >= 0 && lo < hi then
            p := partition(A, lo, hi) 
            quicksort(A, lo, p) // 注意：此时的p已包含在内。
            quicksort(A, p + 1, hi) 

        // 给数组分区
        func partition(A, lo, hi)
        // pivot是数组的中间那一项
        pivot := A[ floor((hi - lo)/2) + lo ] // 通过这种方式，能避免 hi + lo 过大导致数据溢出的问题。

        // 左下标
        i := lo - 1 

        // 右下标
        j := hi + 1

        loop forever 
            // 如果左侧小于基准值，左下标右移至少一位。
            do i := i + 1 while A[i] < pivot
            
            // 如果右侧大于基准值，右下标左移至少一位。
            do j := j - 1 while A[j] > pivot

            // 如果两个下标交叉或错位，返回pivot所在项
            if i >= j then return j
            
            // 左右互换
            swap A[i] with A[j]


#### 1.3.3. 实现方式 (Implementation Issues)

1. **基准的选择 (Choice of pivot)**

    我们通过选择*随机的基准*，或*从前、中、后三个位置的基准取中值（三数取中）*的方案来避免最坏情况的产生。

    > In the very early versions of quicksort, the ***leftmost element of the partition*** would often be chosen as the pivot element. Unfortunately, this causes ***worst-case behavior on already sorted arrays***, which is a rather common use-case. The problem was easily solved by <u>choosing either a random index for the pivot, choosing the middle index of the partition or (especially for longer partitions) choosing the median of the first, middle and last element of the partition for the pivot. </u>(as recommended by Sedgewick)

    对 Lomuto 方案进行三数取中

    

1. **重复元素情况 (Repeated elements)**



3. **当序列较短时，使用 *插入排序* 的效率更高**



### 1.4. 记录时间

利用 [*第四课*][1] 中已经研究好解决方案，我们直接利用其代码即可。具体如下：

#### 1.4.1. 在C语言中

        clock_t start_t, finish_t;
        start_t = clock();	
        ……
        finish_t = clock();
        printf("Run Time: %fs\n", (double)(finish_t - start_t) / CLOCKS_PER_SEC);

#### 1.4.2. 在Python中

        import time
        t = time.time()
        ……
        print(f'coast:{time.time() - t:.4f}s')

### 1.5. 随机数生成

> "随机生成100000个随机数"

1. C中实现：

    我们知道，在C中可以调用 *stdlib.h* 库中的 rand() 函数获取*伪随机数*。
    


### 1.6. 实践环境

利用 [*第四课*][1] 中已经配置好的环境，我们直接在*VS Code*中编写C和Python程序即可。




## 3. 快速排序的编程运行


### 3.1. 使用C实现

1. 直接调用C标准库中的 `qsort()`
    
    比较有趣的是，在C语言标准库*stdlib.h*中，有`qsort()`函数。该函数是R. S. Scowen版本的快速排序的变体。

        void qsort(void *base, size_t nitems, size_t size, int (*compar)(const void *, const void*))
    
    对一个数组`list[]`，`n`是需要排序的数量，通过`sizeof(list[0])`确定数组中每个元素占用空间的大小。
    
    提供一个 `cmp()` 作为指针，确定排序的顺序：

        int cmp (const void * a, const void * b)
        {
            return ( *(int*)a - *(int*)b ); //从小到大的实现方法
            return ( *(int*)b - *(int*)a ); //从大到小的实现方法
        }

    `qsort()` 函数的用法：

        qsort(list, n, sizeof(list[0]), cmp);

### 3.2. 使用Python实现

## 4. 结果比较

### 4.1. 建立列表

|       |   C   | Python  |
| ----: | :----: | :----:  |
| 快排  |  1     |  2      |
| 冒泡  |  3     |  4      |

### 4.2. 数据分析


## 5. 问题解决




## 6. 原创声明

除文中特别指出的知识是从网上学习的以外，内容均由我个人原创。在这里特别列出非原创内容：

- 算法




[1]: https://github.com/jstar0/IntroCSLib/blob/main/K4/
[2]: https://github.com/jstar0/IntroCSLib
[3]: https://github.com/git-for-windows/git/releases/download/v2.42.0.windows.2/Git-2.42.0.2-64-bit.exe
[4]: https://github.com/Molunerfinn/PicGo
[5]: https://www.netlify.com/
[6]: https://railway.app/
[7]: https://vercel.com/
[8]: https://www.aliyun.com/product/oss
[9]: https://cloud.tencent.com/product/cos
[10]: https://en.wikipedia.org/wiki/Quicksort
[11]: https://oi-wiki.org/basic/quick-sort/


[1.1.2.1]: 
